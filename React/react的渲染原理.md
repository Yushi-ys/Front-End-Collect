##### react组件渲染的过程，其实就是JS的执行，由于JS的执行不可中断，而且是单线程，所以如果一个组件特别消耗JS，就会卡住渲染

React16以前，react使用栈结构去渲染，把每一个需要执行的JS从栈中拿出来依次执行，一旦开始渲染，就必须一次性完成整个组件树的更新，如果组件树很大，可能会阻塞主线程，导致页面卡顿

react16之后，通过fiber架构进行优化，fiber架构其实是一种数据结构，存储了组件类型、当前DOM节点、parent、child、兄弟节点（其实就是一个链表结构），采用 DFS 算法去遍历整棵树，每个 Fiber 节点处理完后，React 会检查剩余时间，决定继续或让出主线程

#### Fiber 架构的改进
1. 可中断的异步渲染：将渲染任务拆分成多个小任务（Fiber 节点），允许 React 在浏览器空闲时执行部分任务（基于 浏览器空闲时间requestIdleCallback 或 React自己的调度器scheduler）
2. 优先级调度：高优先级更新（如用户交互）可以打断低优先级渲染（如数据加载），让 UI 更流畅


#### React 的调度器会通过以下逻辑判断是否让出主线程
```js
function shouldYield() {
  // 1. 检查当前时间是否超过帧的截止时间（如 5ms 内必须暂停）
  // 2. 检查是否有更高优先级任务（如用户点击）
  return currentTime >= deadline || needsInterruption;
}
```

react会在内存中维护两颗fiber树(双缓存机制)，一颗current tree，一颗WorkInProgress Tree，分别代表当前屏幕上显示的 UI 对应的 Fiber 树和正在构建的新 Fiber 树（完成后会替换 Current Tree）

#### 这种机制的作用？
这种机制确保渲染过程不会直接破坏当前 UI，提升用户体验

React 的 Diff 算法负责比较新旧 Fiber 树，找出最小变更，diff的三大原则：
1. 同级比较：只对比同一层级的节点，不跨层级比较（复杂度从 O(n³) 降到 O(n)）
2. Key 优化，列表元素使用 key 标识，帮助 React 识别哪些节点可复用
3. 组件类型判断：如果组件类型不同（如 <div> → <span>），直接销毁旧组件，创建新组件

#### 如何从 O(n³) 降到 O(n)
传统树 Diff：遍历旧树的所有节点（O(n)）、对于每个旧节点，遍历新树的所有节点（O(n)），找到匹配项、对匹配的节点递归比较子节点（O(n)）
React Diff 的优化：只进行同级比较，如果发现某节点在不同层级，直接销毁旧节点，创建新节点，最坏情况下（两棵树完全不同），每个节点比较一次 → O(n)，最好情况下（两棵树完全相同），仍为 O(n)

找出最小变更之后，更新真实DOM，根据fiber节点的变更标记(例如：delete、update)，应用所有变更，最后执行副作用，例如useEffect


#### 完整流程
1. 通过setState() 或 useState 触发重新渲染
2. 构建 WorkInProgress Tree，React 从根节点开始深度优先遍历，创建新的 Fiber 节点，对比新旧节点，标记变更（Diff 算法）
3. 调度与中断，如果时间片用完，React 暂停渲染，让浏览器处理高优先级任务（如点击事件）。
4. 提交到 DOM，替换 Current Tree，更新 UI